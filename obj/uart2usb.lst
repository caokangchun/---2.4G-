C51 COMPILER V9.01   UART2USB                                                              11/08/2018 16:54:03 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE UART2USB
OBJECT MODULE PLACED IN .\obj\uart2usb.obj
COMPILER INVOKED BY: D:\Keil_v511\C51\BIN\C51.EXE code\app\src\uart2usb.c LARGE BROWSE INTVECTOR(0X1800) INCDIR(.\code\a
                    -pp\inc;.\code\driver\inc;.\code\system\inc;.\code\usb) DEFINE(__KEIL_C51__) DEBUG OBJECTEXTEND PRINT(.\obj\uart2usb.lst)
                    - OBJECT(.\obj\uart2usb.obj)

line level    source

   1          
   2          #include "includes.h"
   3          
   4          
   5          #ifdef _UART2USB
   6          
   7          //0xaa,spid,reserve,0x55
   8          static uint8_t spidAck[4]={0xaa,0,0,0x55};
   9          
  10          typedef struct
  11          {
  12                  UINT8 prefix1;
  13                  UINT8 prefix2;
  14                  UINT8 sid;
  15                  UINT8 crc;
  16          }CMD_UPLOAD;
  17          
  18          static unsigned char crc_high_first(unsigned char *ptr, unsigned char len)
  19          {
  20   1          unsigned char i; 
  21   1          unsigned char crc=0x00; /* 计算的初始crc值 */ 
  22   1      
  23   1          while(len--)
  24   1          {
  25   2              crc ^= *ptr++;  /* 每次先与需要计算的数据异或,计算完指向下一数据 */  
  26   2              for (i=8; i>0; --i)   /* 下面这段计算过程与计算一个字节crc一样 */  
  27   2              { 
  28   3                  if (crc & 0x80)
  29   3                      crc = (crc << 1) ^ 0x31;
  30   3                  else
  31   3                      crc = (crc << 1);
  32   3              }
  33   2          }
  34   1      
  35   1          return (crc); 
  36   1      }
  37          
  38          static BOOL     isCmdPkt(unsigned char *ptr, unsigned char len)
  39          {
  40   1              //判断长度
  41   1              //判断前序
  42   1              //判断crc
  43   1              CMD_UPLOAD *cmdPtr = (CMD_UPLOAD*)ptr;
  44   1              UINT8 crc;
  45   1              
  46   1              if(len != sizeof(CMD_UPLOAD))
  47   1              {
  48   2                      return FALSE;
  49   2              }
  50   1      
  51   1              if((cmdPtr->prefix1 != 0xfe) || (cmdPtr->prefix2 != 0xef))
  52   1              {
  53   2                      return FALSE;
C51 COMPILER V9.01   UART2USB                                                              11/08/2018 16:54:03 PAGE 2   

  54   2              }
  55   1      
  56   1              crc = crc_high_first(ptr,len-1);
  57   1              if(crc != cmdPtr->crc)
  58   1              {
  59   2                      return FALSE;
  60   2              }
  61   1      
  62   1              return TRUE;
  63   1              
  64   1      }
  65          
  66          
  67          
  68          
  69          static BOOL checkData(unsigned char *ptr, UINT16 len)
  70          {
  71   1              UINT8 crc;
  72   1              
  73   1              crc = crc_high_first(ptr,len-1);
  74   1              if(crc == ptr[len-1])
  75   1              {
  76   2                      return TRUE;
  77   2              }
  78   1      
  79   1              return FALSE;
  80   1      }
  81          
  82          static BOOL ReceiveCompleteAck(UINT8 pid)
  83          {
  84   1              UINT8 ack_tmp[4],ack_len;
  85   1      
  86   1              spidAck[1] = pid;       //写入回复信息中
  87   1      
  88   1              rf_slave.rx_tout = 0;
  89   1              rf_transceiver(RF_RECEIVER, RF_RX_TOUT, spidAck, sizeof(spidAck), ack_tmp, RF_FIFO_MAX, &ack_len);
  90   1              
  91   1      }
*** WARNING C173 IN LINE 91 OF CODE\APP\SRC\UART2USB.C: missing return-expression
  92          
  93          
  94          
  95          #ifdef _RF_HOST
              
              idata UART_RECV uart = {0};
              idata RF_HOST rf_host = {0};
              
              //------------------------------------------------------------------------
              //      Description     :       UART receive data
              //      Parameters      :       none
              //      Return          :       none
              //      Author          :       RAY
              //      Date            :       2014 - 03 - 11
              //------------------------------------------------------------------------
              void uart_receive(UINT8 dat)
              {       
                      uart.time_out = T_OUT_MAX;
              
                      switch(uart.state)
                      {
                              case RECV_IDLE:
                                      if(uart.data_ok != TRUE)
C51 COMPILER V9.01   UART2USB                                                              11/08/2018 16:54:03 PAGE 3   

                                      {
                                              //uart.index = 3;
                                              uart.index_tmp = 0;
                                              uart.state = RECV_DATA;
                                      }
                                      else
                                      {
                                              uart.state = RECV_STOP;
                                              break;
                                      }
                                      
                              case RECV_DATA:
                                      if(uart.index_tmp >= (MAX_BUFF-3))
                                      {
                                              uart.state = RECV_STOP;
                                      }
                                      else
                                      {
                                              uart.buff_tmp[uart.index_tmp++] = dat;
                                      }
                                      break;
                                      
                              case RECV_STOP:
                                      /* discard data */
                                      break;
              
                              default:
                                      uart.state = RECV_IDLE;
                                      break;
                      }
              }
              
              
              //------------------------------------------------------------------------
              //      Description     :       UART data to usb send
              //      Parameters      :       none
              //      Return          :       none
              //      Author          :       RAY
              //      Date            :       2014 - 03 - 11
              //------------------------------------------------------------------------
              BOOL rf_tx_tout(TIME_OUT mode)
              {
                      BOOL flag = FALSE;
                      
                      switch(mode)
                      {
                              case TX_OUT:
                                      if(rf_host.tx_out > RF_SEND_TOUT) // tx time out
                                      {
                                              // tx timeout
                                              printf("tx tout.\r\n");
                                              flag = TRUE;
                                      }
                                      else
                                      {
                                              if(rf_host.rx_init)
                                              {
                                                      flag = TRUE;
                                              }
                                      }
                                      break;
              
C51 COMPILER V9.01   UART2USB                                                              11/08/2018 16:54:03 PAGE 4   

                              case IDLE_OUT:
                                      if(rf_host.idleout > RF_IDLE_TOUT) // idle time out
                                      {
                                              // goto sleep
                                              rf_host.status = RF_PWR_OFF;
                                              
                                              printf("idle tout.\r\n");
                                              flag = TRUE;
                                      }
                                      break;
              
                              case INIT_OUT:
                                      flag = TRUE;
                                      break;
                                      
                              default:
                                      break;
                      }
              
                      return flag;
              }
              
              //------------------------------------------------------------------------
              //      Description     :       UART data to usb send
              //      Parameters      :       none
              //      Return          :       none
              //      Author          :       RAY
              //      Date            :       2014 - 03 - 11
              //------------------------------------------------------------------------
              BOOL rf_host_send(void)
              {
                      BOOL status = FALSE;
                      UINT8 ack_tmp[4];
                      UINT8 ack_len;
                      static UINT8 pkt_id = 0;
              
                      /* clear tx timeout */
                      rf_host.tx_out = 0;
              
                      /* packet id counter */
                      uart.buff[1] = pkt_id & 0x7F;
                      pkt_id++;
              
              RF_TRANSMIT:
              
                      /* rf need to send 2 packets */
                      if(uart.index > RF_FIFO_MAX)
                      {
                              status = rf_transceiver(RF_TRANSFER, RF_TX_TOUT, uart.buff, RF_FIFO_MAX, \
                                                                              ack_tmp, sizeof(ack_tmp), &ack_len);
                                                                                                              
                              if(status) // tx ok, no timeout
                              {
                      #ifdef _RF_ACK_PLD
                                      status = !memcmp(ack_tmp, rf_ack, sizeof(rf_ack));
                          #if 1
                          if(!status) // ack fail, re-transmit
                          {
                              if(rf_tx_tout(TX_OUT))
                              {
                                  goto RF_TRANSMIT;
                              }
C51 COMPILER V9.01   UART2USB                                                              11/08/2018 16:54:03 PAGE 5   

                          }
                          #endif /* 0 */
                      #endif /* _RF_ACK_PLD */
                                      
                                      if(status) // rx ack ok
                                      {
                                              status = rf_transceiver(RF_TRANSFER, RF_TX_TOUT, &uart.buff[RF_FIFO_MAX], \
                                                                                              uart.index - RF_FIFO_MAX, ack_tmp, sizeof(ack_tmp), &ack_len);
                                      }
                              }       
                      }
                      else
                      {
                              status = rf_transceiver(RF_TRANSFER, RF_TX_TOUT, uart.buff, uart.index, \
                                                                              ack_tmp, sizeof(ack_tmp), &ack_len);
                      }
                      
                      if(status) // tx ok, no timeout
                      {
                      #ifdef _RF_ACK_PLD
                              status = !memcmp(ack_tmp, rf_ack, sizeof(rf_ack));
                      #if 1
                      if(!status) // ack fail, re-transmit
                      {
                          if(rf_tx_tout(TX_OUT))
                          {
                              goto RF_TRANSMIT;
                          }
                      }
                      #endif /* 0 */
                      #endif /* _RF_ACK_PLD */
                      }
              
                      if(status) // rx ack ok, tx success
                      {
                              rf_host.idleout = 0; // clear idle cnt
                      }
              
                      return status;
              }
              
              
              //------------------------------------------------------------------------
              //      Description     :       UART data to usb send
              //      Parameters      :       none
              //      Return          :       none
              //      Author          :       RAY
              //      Date            :       2014 - 03 - 11
              //------------------------------------------------------------------------
              BOOL check_same_code(void)
              {
                      BOOL flag = FALSE;
                      
                      if(rf_host.same_flag)
                      {
                              UINT8 tmp;
                              UINT8 len;
                              UINT8 i = 0;
                              
                              flag = TRUE;
                              len = uart.index - 3; // no cnt & pkt & pid
                              
C51 COMPILER V9.01   UART2USB                                                              11/08/2018 16:54:03 PAGE 6   

                              at24cxx_read(LAST_DATA, &tmp, 1);
              
                              if(tmp != len)
                              {
                                      flag = FALSE;
                                      at24cxx_write(LAST_DATA, &len, 1);
                              }
                              else
                              {
                                      /* check if time out for same code is over */
                                      if(rf_host.same_out < rf_host.same_time)
                                      {
                                              for(i = 0; i < len; i++)
                                              {
                                                      at24cxx_read(LAST_DATA + 1 + i, &tmp, 1);
              
                                                      if(tmp != uart.buff[3 + i])
                                                      {
                                                              flag = FALSE;
                                                              break;
                                                      }
                                              }
                                      }
                                      else
                                      {
                                              flag = FALSE;
                                      }
                              }
                              
                              // clear time out cnt
                              rf_host.same_out = 0;
              
                              if(!flag)
                              {
                                      at24cxx_write(LAST_DATA + 1, (UINT8 *)&uart.buff[3], len);
                              }
                      }
              
                      return flag;
              }
              
              //------------------------------------------------------------------------
              //      Description     :       UART data to usb send
              //      Parameters      :       none
              //      Return          :       none
              //      Author          :       RAY
              //      Date            :       2014 - 03 - 11
              //------------------------------------------------------------------------
              BOOL store_code_data(void)
              {
                  #define E2_VOL_1    E2_VOLUME*9/10
                  #define E2_VOL_2    E2_VOLUME*95/100
                  
                      BOOL flag = TRUE;
                      UINT8 len;
              
                  if(rf_host.store_addr > E2_VOL_2)
                  {
                  #if 0
                      watchdog_feed();
                      PCINT1 = ON;
                      delay_1ms(250);
C51 COMPILER V9.01   UART2USB                                                              11/08/2018 16:54:03 PAGE 7   

                      delay_1ms(250);
                      PCINT1 = OFF;
                      watchdog_feed();
                  #else
                      beep_ctrl(1, 500);
                  #endif /* 0 */
                      return FALSE;
                  }
                  else
                  {
                      if(rf_host.store_addr > E2_VOL_1)
                      {
                      #if 0
                          watchdog_feed();
                          PCINT1 = ON;
                          delay_1ms(250);
                          PCINT1 = OFF;
                          watchdog_feed();
                      #else
                          beep_ctrl(1, 250);
                      #endif /* 0 */
                          //return FALSE;
                      }
                  }
                  
                      //len = uart.index - 2; // no cnt & pid
                      len = uart.buff[0] - 2; // no cnt & pid
                      uart.buff[2] = len; // pid -> len
              
                      rf_host.cur_num++;
                      rf_host.total_num++;
                      at24cxx_write(TOTAL_NUM, (UINT8 *)&rf_host.total_num, 2);
                      
                      printf("T=%d,Cur=%d\r\n", (UINT16)rf_host.total_num, (UINT16)rf_host.cur_num);
              
                      at24cxx_write(rf_host.store_addr, (UINT8 *)&uart.buff[2], len);
                      
                      rf_host.store_addr += len;
                      at24cxx_write(STORE_ADDR, (UINT8 *)&rf_host.store_addr, 2);
              
                      rf_host.idleout = 0; // clear idle cnt
                      return flag;
              }
              
              //------------------------------------------------------------------------
              //      Description     :       UART data to usb send
              //      Parameters      :       none
              //      Return          :       none
              //      Author          :       RAY
              //      Date            :       2014 - 03 - 11
              //------------------------------------------------------------------------
              void rf_slave_init(void)
              {
                      UINT8 rf_pipe_bak;
                      UINT8 tx_cnt = 0;
                      
                      rf_pipe_bak = xn297l.pipe_index;
                      xn297l.pipe_index = 16;
                      rf_set_ch();
              
                      uart_int_disable();
              
C51 COMPILER V9.01   UART2USB                                                              11/08/2018 16:54:03 PAGE 8   

                      while(1)
                      {
                              if(rf_host_send())
                              {
                                      break;
                              }
                              else
                              {
                                      if(++tx_cnt > 6)
                                      {
                                              tx_cnt = 0;
                                              
                                              if(rf_host.beep)
                                              {
                                                      beep_ctrl(1, 80);
                                  delay_1ms(60);
                                              }
                                      }
                              }
              
                              if(rf_tx_tout(IDLE_OUT))
                              {
                                      break;
                              }
              
                              if(UART_INT_FLAG)
                              {
                                      //uart_rx_disable();
                                      uart_disable();
                                      UOR = 0;
                                      URF = 0;
                                      break;
                              }
                      }
                      
                      rf_host.rx_init = FALSE;
                      xn297l.pipe_index = rf_pipe_bak;
                      rf_set_ch();
              
                      uart_int_enable();
                      uart_enable();
              }
              
              //------------------------------------------------------------------------
              //      Description     :       UART data to usb send
              //      Parameters      :       none
              //      Return          :       none
              //      Author          :       RAY
              //      Date            :       2014 - 03 - 11
              //------------------------------------------------------------------------
              BOOL uart_to_rf(void)
              {
                      BOOL status = FALSE;
                      
                      if(uart.data_ok)
                      {
                          //__disable_interrupt();
                          //uart_int_disable();
                      uart.index = uart.index_tmp;
                          memcpy(&uart.buff[3], uart.buff_tmp, uart.index);
                      uart.data_ok = FALSE;
                      //__enable_interrupt();
C51 COMPILER V9.01   UART2USB                                                              11/08/2018 16:54:03 PAGE 9   

                      //uart_int_enable();
              
                      uart.index += 3;
              
                              /* tx total bytes */
                              uart.buff[0] = uart.index;
              
                              /* tx host id number */
                              uart.buff[2] = rf_host.pid;
                              
                              printf("host get data.\r\n");
                              #if 0
                              {
                                      UINT8 i;
                                      
                                      for(i = 0; i < uart.buff[0]-3; i++)
                                      {
                                              //printf("-%x", (UINT16)uart.buff[i]);
                                              uart_send_byte(uart.buff[3+i]);
                                      }
                                      //printf("\r\n");
                                      //uart_send_byte(0x0a);
                              }
                              #endif
                      
                              watchdog_feed();
              
                              if(rf_host_cmd(uart.buff) != TRUE)
                              {
                                      UINT8 beep_cnt = 0;
                                      
                                      if(rf_host.store_flag)
                                      {
                                              if(check_same_code() != TRUE)
                                              {
                                                      /* store diff code */
                                                      beep_cnt = 0;
                                                      store_code_data();
                                              }
                                              else
                                              {
                                                      beep_cnt = 5;
                                              }
                                      }
                                      else
                                      {
                                              if(check_same_code() != TRUE)
                                              {
                                                      if(rf_host_send() != TRUE)
                                                      {
                                                              /* store diff code */
                                                              beep_cnt = 3;
                                                              store_code_data();
                                                      }
                                                      else
                                                      {
                                                              beep_cnt = 1;
                                                      }
                                                      
                                                      // enable data rx
                                  //uart.data_ok = 0;
                                              }
C51 COMPILER V9.01   UART2USB                                                              11/08/2018 16:54:03 PAGE 10  

                                              else
                                              {
                                                      beep_cnt = 5;
                                              }
                                      }
              
                                      if(rf_host.beep)
                                      {
                                              beep_ctrl(beep_cnt, 80);
                                      }
                              }
                              else
                              {
                                      if(rf_host.rx_init) // slave data
                                      {
                                              rf_slave_init();
                                      }
                              }
              
                              watchdog_feed();
                              //uart.data_ok = 0;
                      }
                      else
                      {
                              //printf(".");
                              mcu_goto_idle();
                              rf_tx_tout(IDLE_OUT); // idle timeout
                      }
                      
                      return status;
              }
              
              #endif
 582          
 583          #ifdef _RF_SLAVE
 584          
 585          xdata RF_SLAVE rf_slave = {0};// _at_ 0xA8;//
 586          
 587          //------------------------------------------------------------------------
 588          //      Description     :       UART data to usb send
 589          //      Parameters      :       none
 590          //      Return          :       none
 591          //      Author          :       RAY
 592          //      Date            :       2014 - 03 - 11
 593          //------------------------------------------------------------------------
 594          BOOL rf_rx_tout(void)
 595          {
 596   1              if(rf_slave.rx_tout > RF_RECV_TOUT) // rx time out
 597   1              {
 598   2                      printf("rx tout.\r\n");
 599   2                      return TRUE;
 600   2              }
 601   1      
 602   1              return FALSE;
 603   1      }
 604          
 605          //------------------------------------------------------------------------
 606          //      Description     :       data to usb send
 607          //      Parameters      :       none
 608          //      Return          :       none
 609          //      Author          :       RAY
 610          //      Date            :       2014 - 03 - 11
C51 COMPILER V9.01   UART2USB                                                              11/08/2018 16:54:03 PAGE 11  

 611          //------------------------------------------------------------------------
 612          void usb_data_proc(UINT8 mode, UINT8 *data_buff)
 613          {
 614   1              if(rf_slave.pkt_id != (data_buff[1] & 0x1F))
 615   1              {
 616   2                      rf_slave.clear_t = RF_SEND_TOUT;
 617   2                      
 618   2                      if(mode != INIT_MODE)
 619   2                      {
 620   3                          UINT8 crc_l = data_buff[data_buff[0]-1];
 621   3                          UINT8 crc_h = data_buff[data_buff[0]-2];
 622   3      
 623   3                          UINT16 crc = calc_crc16_ccitt(&data_buff[HEAD_LEN], data_buff[0]-HEAD_LEN-2);
 624   3                          
 625   3                  if((((crc>>8) & 0xFF) == crc_h) && ((crc & 0xFF) == crc_l))
 626   3                  {
 627   4                              UINT8 language;
 628   4                              
 629   4                              rf_slave.add_type = DAT_RIGHT(data_buff[1], 5);
 630   4                              //language = DAT_RIGHT(data_buff[1], 6);
 631   4                              language = data_buff[3];
 632   4      
 633   4                      #if 0
                                      if(language & 0x80)
                                      {
                                          usb_key_send(NULL, 1, language & 0x80);
                                              
                                              /* Wait 1600Ms */
                                              delay_1ms(250);
                                              watchdog_feed();
                                              delay_1ms(250);
                                              watchdog_feed();
                                              delay_1ms(250);
                                              watchdog_feed();
                                              delay_1ms(250);
                                              watchdog_feed();
                                              
                                              delay_1ms(250);
                                              watchdog_feed();
                                              delay_1ms(250);
                                              watchdog_feed();
                                              delay_1ms(100);
                                      }
                              #endif /* 0 */
 655   4                              
 656   4                              //if(rf_slave.pid_flag)
 657   4                              if(rf_slave.add_type)
 658   4                              {
 659   5                                      UINT8 tmp_dat[4];
 660   5                                      UINT8 len = 0;
 661   5                                      UINT8 tmp;
 662   5                                      UINT8 host_id = data_buff[2]; 
 663   5      
 664   5                                      tmp = host_id / 100;
 665   5                                      if(tmp != 0)
 666   5                                      {
 667   6                                              tmp_dat[len++] = tmp + '0';
 668   6                                      }
 669   5      
 670   5                                      tmp = host_id % 100 / 10;
 671   5                                      if((len != 0) || (tmp != 0))
 672   5                                      {
C51 COMPILER V9.01   UART2USB                                                              11/08/2018 16:54:03 PAGE 12  

 673   6                                              tmp_dat[len++] = tmp + '0';
 674   6                                      }
 675   5      
 676   5                                      tmp_dat[len++] = host_id % 10 + '0';
 677   5                                      
 678   5                                      switch(rf_slave.add_type)
 679   5                                      {
 680   6                                              case ADD_TAB:
 681   6                                                      tmp_dat[len++] = 0x09/*hid_tab*/;
 682   6                                                      break;
 683   6      
 684   6                                              case ADD_BLANK:
 685   6                                                      tmp_dat[len++] = 0x20/*hid_space*/;
 686   6                                                      break;
 687   6      
 688   6                                              case ADD_LINE:
 689   6                                                      tmp_dat[len++] = 0x2D/*hid_underline*/;
 690   6                                                      break;
 691   6      
 692   6                                          case ADD_NOT:
 693   6                                              break;
 694   6      
 695   6                                              default:
 696   6                                                      break;
 697   6                                      }
 698   5                                      
 699   5                                      watchdog_feed();
 700   5      
 701   5                                      /* send prefix for ID data */
 702   5                                      usb_key_send(tmp_dat, len, language & 0x7F);
 703   5                              }
 704   4      
 705   4                              watchdog_feed();
 706   4      
 707   4                              /* send scan data from rf host ------------------------- */
 708   4                              usb_key_send(&data_buff[HEAD_LEN], data_buff[0]-HEAD_LEN-2, language & 0x7F);
 709   4                              }
 710   3                              else
 711   3                              {
 712   4                                  return;
 713   4                              }
 714   3                      }
 715   2                      else
 716   2                      {
 717   3                              /* handle for init cmd */
 718   3                              //rf_slave_cmd(data_buff);
 719   3                      }
 720   2                      
 721   2                      rf_slave.pkt_id = data_buff[1] & 0x1F;
 722   2              }
 723   1      }
 724          
 725          //------------------------------------------------------------------------
 726          //      Description     :       data to usb send
 727          //      Parameters      :       none
 728          //      Return          :       none
 729          //      Author          :       RAY
 730          //      Date            :       2014 - 03 - 11
 731          //------------------------------------------------------------------------
 732          void usb_data_proc1(UINT8 mode, UINT8 *data_buff)       
 733          {
 734   1              rf_slave.clear_t = RF_SEND_TOUT;
C51 COMPILER V9.01   UART2USB                                                              11/08/2018 16:54:03 PAGE 13  

 735   1              
 736   1              if(mode != INIT_MODE)
 737   1              {
 738   2                      UINT16 total_len;
 739   2      
 740   2                      total_len = data_buff[1];
 741   2                      total_len <<= 8;
 742   2                      total_len += data_buff[2];
 743   2      
 744   2                      
 745   2                      watchdog_feed();
 746   2      
 747   2                      /* send scan data from rf host ------------------------- */
 748   2                      usb_key_send(&data_buff[HEAD_LEN+2], total_len - (HEAD_LEN+2)-1, 0);            //-1  crc
 749   2                      
 750   2              }
 751   1              
 752   1      }
 753          //void usb_data_proc1(UINT8 mode, UINT8 *data_buff)     
 754          //{
 755          //      if(rf_slave.pkt_id != (data_buff[3] & 0x1F))
 756          //      {
 757          //              rf_slave.clear_t = RF_SEND_TOUT;
 758          //              
 759          //              if(mode != INIT_MODE)
 760          //              {
 761          //                      UINT8 language;
 762          //                      UINT16 total_len;
 763          //
 764          //                      total_len = data_buff[1];
 765          //                      total_len <<= 8;
 766          //                      total_len += data_buff[2];
 767          //
 768          //                      //if(!usb_type_cmd(&data_buff[HEAD_LEN+2], total_len-(HEAD_LEN+2)))
 769          //                      {
 770          //                      rf_slave.add_type = DAT_RIGHT(data_buff[3], 5);
 771          //                      language = data_buff[5];
 772          //
 773          //                #if 0
 774          //                      if(language & 0x80)
 775          //                      {
 776          //                          usb_key_send(NULL, 1, language & 0x80);
 777          //                              
 778          //                              /* Wait 1600Ms */
 779          //                              delay_1ms(250);
 780          //                              watchdog_feed();
 781          //                              delay_1ms(250);
 782          //                              watchdog_feed();
 783          //                              delay_1ms(250);
 784          //                              watchdog_feed();
 785          //                              delay_1ms(250);
 786          //                              watchdog_feed();
 787          //                              
 788          //                              delay_1ms(250);
 789          //                              watchdog_feed();
 790          //                              delay_1ms(250);
 791          //                              watchdog_feed();
 792          //                              delay_1ms(100);
 793          //                      }
 794          //                #endif /* 0 */
 795          //                      
 796          //                      //if(rf_slave.pid_flag)
C51 COMPILER V9.01   UART2USB                                                              11/08/2018 16:54:03 PAGE 14  

 797          //                      if(rf_slave.add_type)
 798          //                      {
 799          //                              UINT8 tmp_dat[4];
 800          //                              UINT8 len = 0;
 801          //                              UINT8 tmp;
 802          //                              UINT8 host_id = data_buff[4]; 
 803          //
 804          //                              tmp = host_id / 100;
 805          //                              if(tmp != 0)
 806          //                              {
 807          //                                      tmp_dat[len++] = tmp + '0';
 808          //                              }
 809          //
 810          //                              tmp = host_id % 100 / 10;
 811          //                              if((len != 0) || (tmp != 0))
 812          //                              {
 813          //                                      tmp_dat[len++] = tmp + '0';
 814          //                              }
 815          //
 816          //                              tmp_dat[len++] = host_id % 10 + '0';
 817          //                              
 818          //                              switch(rf_slave.add_type)
 819          //                              {
 820          //                                      case ADD_TAB:
 821          //                                              //tmp_dat[len++] = 0x09/*hid_tab*/;
 822          //                                              break;
 823          //
 824          //                                      case ADD_BLANK:
 825          //                                              tmp_dat[len++] = 0x20/*hid_space*/;
 826          //                                              break;
 827          //
 828          //                                      case ADD_LINE:
 829          //                                              tmp_dat[len++] = 0x2D/*hid_underline*/;
 830          //                                              break;
 831          //
 832          //                                  case ADD_NOT:
 833          //                                      break;
 834          //
 835          //                                      default:
 836          //                                              break;
 837          //                              }
 838          //                              
 839          //                              watchdog_feed();
 840          //
 841          //                              /* send prefix for ID data */
 842          //                              usb_key_send(tmp_dat, len, language);
 843          //                      }
 844          //
 845          //                      watchdog_feed();
 846          //
 847          //                      /* send scan data from rf host ------------------------- */
 848          //                      usb_key_send(&data_buff[HEAD_LEN+2], total_len - (HEAD_LEN+2), language);
 849          //                      }
 850          //              }
 851          //              else
 852          //              {
 853          //                      /* handle for init cmd */
 854          //                      //rf_slave_cmd(data_buff);
 855          //              }
 856          //              
 857          //              rf_slave.pkt_id = data_buff[3] & 0x1F;
 858          //      }
C51 COMPILER V9.01   UART2USB                                                              11/08/2018 16:54:03 PAGE 15  

 859          //}
 860          
 861          #ifdef RF_250KBPS
 862          
 863          static UINT8 rx_temp[RF_FIFO_MAX]={0};
 864          
 865          
 866          
 867          BOOL rf_to_usb(UINT8 mode)
 868          {
 869   1              BOOL rx_ok;
 870   1              UINT8 i;
 871   1              UINT8 ulen;
 872   1              UINT8 ack_data[4];
 873   1              UINT8 bag_id;
 874   1              UINT16 total_len = 0;
 875   1              UINT8 *rx_index = NULL;
 876   1      
 877   1              /* clear recv time out */
 878   1              rf_slave.rx_tout = 0;
 879   1      
 880   1              for(i = 0; i < 100; i++)
 881   1              {
 882   2              RF_RECEIVE:
 883   2                  
 884   2              watchdog_feed();
 885   2                  
 886   2                      if(mode == INIT_MODE)
 887   2                      {
 888   3                              rf_get_mac(ack_data); // ack MAC to Host
 889   3                      }
 890   2                      else // DATA MODE
 891   2                      {
 892   3                              //my_memcpy(ack_data, (code_ptr *)&rf_ack[i][0], ACK_C);
 893   3                              memcpy(ack_data, &rf_ack[0][0], ACK_C);
 894   3                      }
 895   2      
 896   2                      if(0 != i)      //非第一组
 897   2                      {
 898   3                              rx_index = &rf_slave.buff[i*(RF_FIFO_MAX-1)];
 899   3                      }
 900   2                      else            //第一组数据
 901   2                      {
 902   3                              rx_index = rx_temp;
 903   3                      }
 904   2                      
 905   2                      //接收
 906   2                      rx_ok = rf_transceiver(RF_RECEIVER, RF_RX_TOUT, ack_data, sizeof(ack_data), \
 907   2                                                                 rx_index, RF_FIFO_MAX, &ulen);
 908   2      
 909   2                      if(rx_ok) // get RF data
 910   2                      {
 911   3                              /* clear rx time out */
 912   3                              rf_slave.rx_tout = 0;
 913   3      
 914   3      
 915   3                              /*添加命令包*/
 916   3                                      if(isCmdPkt(rx_index, ulen))    //是命令包
 917   3                                      {
 918   4                                              if(((CMD_UPLOAD*)rx_index)->sid == rf_slave.pkt_id)
 919   4                                              {
 920   5                                                      usb_data_proc1(mode, rf_slave.buff);    //usb上传 
C51 COMPILER V9.01   UART2USB                                                              11/08/2018 16:54:03 PAGE 16  

 921   5                                                      rf_slave.pkt_id = INIT_ID; //clear pid
 922   5                                                      break;
 923   5                                              }
 924   4                                              return;
*** WARNING C173 IN LINE 924 OF CODE\APP\SRC\UART2USB.C: missing return-expression
 925   4                                      }
 926   3                              /**/
 927   3      
 928   3      
 929   3      
 930   3      
 931   3      
 932   3      
 933   3      
 934   3      
 935   3      
 936   3      
 937   3      
 938   3      
 939   3      
 940   3                              /* get current data bag id */
 941   3                              bag_id = rx_index[0];
 942   3      
 943   3                              if((bag_id >= 1) & (bag_id <= 102)) // support 102 bag
 944   3                              {
 945   4                                      if(bag_id == (i + 1)) // bag id is correct
 946   4                                      {
 947   5                                              memcpy(rx_index, rx_index + 1, ulen - 1); // shift left one byte                 //左移1字节
 948   5                                              total_len += (ulen - 1);
 949   5      
 950   5                                              if(1==bag_id)
 951   5                                              {
 952   6                                                      //crc
 953   6                                                      if(rx_index[0] == crc_high_first(&rx_index[1], ulen - 1 - 1))   //ulen-bagid-crc
 954   6                                                      {
 955   7                                                              if(rx_index[4] == rf_slave.pkt_id)      //spid == pid
 956   7                                                              {
 957   8                                                                      usb_data_proc1(mode, rf_slave.buff);    //usb上传       
 958   8                                                                      rf_slave.pkt_id = INIT_ID; //clear pid
 959   8                                                              }
 960   7                                                              memcpy(&rf_slave.buff[0], rx_index, ulen - 1);  //将数据写入rf_slave.buff
 961   7                                                      }
 962   6                                                      else    //如果crc错误，退出
 963   6                                                      {
 964   7                                                              return;
*** WARNING C173 IN LINE 964 OF CODE\APP\SRC\UART2USB.C: missing return-expression
 965   7                                                      }
 966   6      
 967   6                                              }
 968   5                                      }
 969   4                              #if 1
 970   4                                      else if(bag_id == i) // bag id to be last one
 971   4                                      {
 972   5                                              // receive again
 973   5                                              goto RF_RECEIVE;
 974   5                                      }
 975   4                              #endif /* 0 */
 976   4                                      else // bag id is incorrect
 977   4                                      {
 978   5                                              rx_ok = 0;
 979   5                                              break;
 980   5                                      }
C51 COMPILER V9.01   UART2USB                                                              11/08/2018 16:54:03 PAGE 17  

 981   4                              }
 982   3                              else // bag id is incorrect
 983   3                              {
 984   4                                      rx_ok = 0;
 985   4                                      break;
 986   4                              }
 987   3                      }
 988   2                      else
 989   2                      {
 990   3                              break; // RF rx timeout
 991   3                      }
 992   2      
 993   2                      if(rx_ok)
 994   2                      {
 995   3                              if(mode == DATA_MODE)
 996   3                              {
 997   4                                      //if(rf_slave.buff[0] == 0xFF)
 998   4                                      {
 999   5                                          UINT16 temp_len;
1000   5      
1001   5                                          temp_len = rf_slave.buff[1];
1002   5                                          temp_len <<= 8;
1003   5                                          temp_len += rf_slave.buff[2];
1004   5      
1005   5                                          if(temp_len == total_len) // full data bag received
1006   5                                          {
1007   6                                              // last bag may need more ack
1008   6      //                                      rf_slave.rx_tout = RF_RECV_TOUT;
1009   6      //                                      rf_transceiver(RF_RECEIVER, 30, ack_data, sizeof(ack_data), &i, 1, &ulen);
1010   6      
1011   6      //                        beep_wait_over();
1012   6      //                        delay_1ms(500);               //10
1013   6      //                        beep_enable(60);
1014   6      
1015   6                                      /* handle the received rf data */
1016   6                                                      //crc校验
1017   6                                                      //记录spid
1018   6                                                      //返回spid
1019   6      
1020   6                                                      if(checkData(&rf_slave.buff[0],temp_len))
1021   6                                                      {
1022   7                                                              rf_slave.pkt_id = (rf_slave.buff[3] & 0x1F);    //记录rf_slave.pkt_id 
1023   7                                                              ReceiveCompleteAck(rf_slave.pkt_id);
1024   7                                                      }               
1025   6                                                      
1026   6                                              break;
1027   6                                          }
1028   5                                      }
1029   4                              }
1030   3      
1031   3                      }
1032   2              }
1033   1          
1034   1              //memset(rf_slave.buff, 0, sizeof(rf_slave.buff));
1035   1      
1036   1              return rx_ok;
1037   1      }
1038          
1039          
1040          
1041          
1042          
C51 COMPILER V9.01   UART2USB                                                              11/08/2018 16:54:03 PAGE 18  

1043          
1044          //BOOL rf_to_usb(UINT8 mode)
1045          //{
1046          //      BOOL rx_ok;
1047          //      UINT8 i;
1048          //      UINT8 ulen;
1049          //      UINT8 ack_data[4];
1050          //      UINT8 bag_id;
1051          //      UINT16 total_len = 0;
1052          //      UINT8 *rx_index = NULL;
1053          //
1054          //      /* clear recv time out */
1055          //      rf_slave.rx_tout = 0;
1056          //
1057          //      for(i = 0; i < 100; i++)
1058          //      {
1059          //      RF_RECEIVE:
1060          //          
1061          //        watchdog_feed();
1062          //          
1063          //              if(mode == INIT_MODE)
1064          //              {
1065          //                      rf_get_mac(ack_data); // ack MAC to Host
1066          //              }
1067          //              else // DATA MODE
1068          //              {
1069          //                      //my_memcpy(ack_data, (code_ptr *)&rf_ack[i][0], ACK_C);
1070          //                      memcpy(ack_data, &rf_ack[0][0], ACK_C);
1071          //              }
1072          //
1073          //              if(0 != i)      //非第一组
1074          //              {
1075          //                      rx_index = &rf_slave.buff[i*(RF_FIFO_MAX-1)];
1076          //              }
1077          //              else            //第一组数据
1078          //              {
1079          //                      rx_index = rx_temp;
1080          //              }
1081          //              
1082          //              //接收
1083          //              rx_ok = rf_transceiver(RF_RECEIVER, RF_RX_TOUT, ack_data, sizeof(ack_data), \
*** WARNING C329 IN LINE 1083 OF code\app\src\uart2usb.c: single-line comment contains line-continuation
1084          //                                                         rx_index, RF_FIFO_MAX, &ulen);
1085          //
1086          //              if(rx_ok) // get RF data
1087          //              {
1088          //                      /* clear rx time out */
1089          //                      rf_slave.rx_tout = 0;
1090          //
1091          //                      /* get current data bag id */
1092          //                      bag_id = rx_index[0];
1093          //
1094          //                      if((bag_id >= 1) & (bag_id <= 102)) // support 102 bag
1095          //                      {
1096          //                              if(bag_id == (i + 1)) // bag id is correct
1097          //                              {
1098          //                                      memcpy(rx_index, rx_index + 1, ulen - 1); // shift left one byte                 //左移1字节
1099          //                                      total_len += (ulen - 1);
1100          //
1101          //
1102          //
1103          //
C51 COMPILER V9.01   UART2USB                                                              11/08/2018 16:54:03 PAGE 19  

1104          ///*添加命令包*/
1105          ////                                    if(isCmdPkt(rx_index, ulen - 1))        //命令 
1106          ////                                    {
1107          ////                                            if(((CMD_UPLOAD*)(rx_index+6))->sid == rf_slave.pkt_id)
1108          ////                                            {
1109          ////                                                    usb_data_proc1(mode, rf_slave.buff);    //usb上传 
1110          ////                                                    rf_slave.pkt_id = INIT_ID; //clear pid
1111          ////                                            }
1112          ////                                            break;
1113          ////                                    }
1114          ///**/                                  
1115          //
1116          //
1117          //
1118          //
1119          //
1120          //
1121          //                                      if(1==bag_id)
1122          //                                      {
1123          //                                              //crc
1124          //                                              if(rx_index[0] == crc_high_first(&rx_index[1], ulen - 1 - 1))   //ulen-bagid-crc
1125          //                                              {
1126          //                                                      if(rx_index[4] == rf_slave.pkt_id)      //spid == pid
1127          //                                                      {
1128          //                                                              usb_data_proc1(mode, rf_slave.buff);    //usb上传       
1129          //                                                              rf_slave.pkt_id = INIT_ID; //clear pid
1130          //                                                      }
1131          //                                                      memcpy(&rf_slave.buff[0], rx_index, ulen - 1);  //将数据写入rf_slave.buff
1132          //                                              }
1133          //                                              else    //如果crc错误，退出
1134          //                                              {
1135          //                                                      return;
1136          //                                              }
1137          //
1138          //                                      }
1139          //                              }
1140          //                      #if 1
1141          //                              else if(bag_id == i) // bag id to be last one
1142          //                              {
1143          //                                      // receive again
1144          //                                      goto RF_RECEIVE;
1145          //                              }
1146          //                      #endif /* 0 */
1147          //                              else // bag id is incorrect
1148          //                              {
1149          //                                      rx_ok = 0;
1150          //                                      break;
1151          //                              }
1152          //                      }
1153          //                      else // bag id is incorrect
1154          //                      {
1155          //                              rx_ok = 0;
1156          //                              break;
1157          //                      }
1158          //              }
1159          //              else
1160          //              {
1161          //                      break; // RF rx timeout
1162          //              }
1163          //
1164          //              if(rx_ok)
1165          //              {
C51 COMPILER V9.01   UART2USB                                                              11/08/2018 16:54:03 PAGE 20  

1166          //                      if(mode == DATA_MODE)
1167          //                      {
1168          //                              //if(rf_slave.buff[0] == 0xFF)
1169          //                              {
1170          //                                  UINT16 temp_len;
1171          //
1172          //                                  temp_len = rf_slave.buff[1];
1173          //                                  temp_len <<= 8;
1174          //                                  temp_len += rf_slave.buff[2];
1175          //
1176          //                                  if(temp_len == total_len) // full data bag received
1177          //                                  {
1178          //                                      // last bag may need more ack
1179          ////                                            rf_slave.rx_tout = RF_RECV_TOUT;
1180          ////                                            rf_transceiver(RF_RECEIVER, 30, ack_data, sizeof(ack_data), &i, 1, &ulen);
1181          //
1182          ////                        beep_wait_over();
1183          ////                        delay_1ms(500);             //10
1184          ////                        beep_enable(60);
1185          //
1186          //                              /* handle the received rf data */
1187          //                                              //crc校验
1188          //                                              //记录spid
1189          //                                              //返回spid
1190          //
1191          //                                              if(checkData(&rf_slave.buff[0],temp_len))
1192          //                                              {
1193          //                                                      rf_slave.pkt_id = (rf_slave.buff[3] & 0x1F);    //记录rf_slave.pkt_id 
1194          //                                                      ReceiveCompleteAck(rf_slave.pkt_id);
1195          //                                              }               
1196          //                                              
1197          //                                      break;
1198          //                                  }
1199          //                              }
1200          //                      }
1201          //
1202          //              }
1203          //      }
1204          //    
1205          //      //memset(rf_slave.buff, 0, sizeof(rf_slave.buff));
1206          //
1207          //      return rx_ok;
1208          //}
1209          #else
              
              //------------------------------------------------------------------------
              //      Description     :       UART data to usb send
              //      Parameters      :       none
              //      Return          :       none
              //      Author          :       RAY
              //      Date            :       2014 - 03 - 11
              //------------------------------------------------------------------------
              BOOL rf_to_usb(UINT8 mode)
              {
                      UINT8 ulen1 = 0, ulen2 = 0;
                      BOOL rx_ok;
                      //UINT8 ack_data[4] = {STX, 0x01, 0xFE, ETX};
                      UINT8 ack_data[4];
              
                      if(mode == INIT_MODE)
                      {
                              rf_get_mac(ack_data); // ack MAC to Host
C51 COMPILER V9.01   UART2USB                                                              11/08/2018 16:54:03 PAGE 21  

                      }
                      else // DATA MODE
                      {
                              //my_memcpy(ack_data, (code_ptr *)rf_ack, 4);
                              my_memcpy(ack_data, (code_ptr *)&rf_ack[0][0], ACK_C);
                      }
              
                      /* clear recv time out */
                      rf_slave.rx_tout = 0;
              
                      rx_ok = rf_transceiver(RF_RECEIVER, RF_RX_TOUT, ack_data, sizeof(ack_data), \
                                                                      rf_slave.buff, RF_FIFO_MAX, &ulen1);
              
                      if(rx_ok && ulen1)
                      {
                      #if 0
                              UINT8 i;
                              watchdog_feed();
                              
                              printf("1st pkt :\r\n");
                              
                              for(i = 0; i < /*ulen1*/rf_slave.buff[0]-3; i++)
                              {
                                      printf("+%x", (UINT16)rf_slave.buff[i]);
                                      uart_send_byte(rf_slave.buff[3+i]);
                              }
                              uart_send_byte(0x0a);
                              printf("\r\n");
                      #endif
              
                              if((ulen1 == sizeof(ack_data)) && \
                              (!memcmp(ack_data, rf_slave.buff, ulen1)))
                              {
                                      // idle or ping pkt
                                      rx_ok = 0;
                              }
                              else
                              {
                                      /* data length is in valid range of the buffer -------------*/
                                      if((rf_slave.buff[0] > RF_FIFO_MAX) && (rf_slave.buff[0] <= MAX_BUFF))
                                      {
                                              /* may be last 2nd pkt or error pkt */
                                              if(ulen1 != RF_FIFO_MAX)
                                              {
                                                      rx_ok = 0;
                                              }
                                              else
                                              {
                                                      UINT8 retry = 0;
              
                                                      //printf("2nd pkt :\r\n");
                                                      
                                                      /* clear recv time out */
                                                      rf_slave.rx_tout = 0;//RF_RECV_TOUT - 1000; // 1s left
                                                      
                                              RETRY_RX:       
                                                      rx_ok = rf_transceiver(RF_RECEIVER, RF_RX_TOUT, ack_data, sizeof(ack_data), \
                                                                                                      &rf_slave.buff[RF_FIFO_MAX], MAX_BUFF - RF_FIFO_MAX, &ulen2);
              
                                                      if(rx_ok && ulen2)
                                                      {
                                                      #if 0
C51 COMPILER V9.01   UART2USB                                                              11/08/2018 16:54:03 PAGE 22  

                                                              watchdog_feed();
                                                              
                                                              for(i = 0; i < ulen2; i++)
                                                              {
                                                                      printf("-%x", (UINT16)rf_slave.buff[ulen1+i]);
                                                              }
                                                              printf("\r\n");
                                                      #endif
                                                      
                                                              if((ulen2 == sizeof(ack_data)) && \
                                                              (!memcmp(ack_data, &rf_slave.buff[RF_FIFO_MAX], ulen2)))
                                                              {
                                                                      // idle or ping pkt
                                                                      rx_ok = 0;
                                                              }
                                                              else
                                                              {
                                                                      if(rf_slave.buff[0] != (ulen1 + ulen2) && \
                                                                      (!memcmp(rf_slave.buff, &rf_slave.buff[ulen1], ulen2)))
                                                                      {
                                                                              /* may be the 1st pkt */
                                                                              if(++retry < 3)
                                                                              {
                                                                                      ulen2 = 0;
                                                                                      goto RETRY_RX;
                                                                              }
                                                                              else
                                                                              {
                                                                                      rx_ok = 0;
                                                                              }
                                                                      }
                                                              }
                                                      }
                                                      else
                                                      {
                                                              rx_ok = 0;
                                                      }
                                              }
                                      }
                                      else
                                      {
                                              /* may be last 2nd pkt or error pkt */
                                              if(rf_slave.buff[0] != ulen1)
                                              {
                                                      rx_ok = 0;
                                              }
                                              else
                                              {
                                                      // need to do:
                                              }
                                      }
                                      
                                      if(rx_ok && (ulen1 || ulen2))
                                      {
                                      #if 0
                                              UINT8 i;
                                              watchdog_feed();
                                              
                                              printf("send key.\r\n");
                                              
                                              for(i = 0; i < rf_slave.buff[0]; i++)
                                              {
C51 COMPILER V9.01   UART2USB                                                              11/08/2018 16:54:03 PAGE 23  

                                                      printf("%x, ", (UINT16)rf_slave.buff[i]);
                                              }
                                              printf("\r\n");
                                      #endif
                              
                              PCINT1 = ON; // led on
              
                                      /* handle the received rf data */
                                      usb_data_proc(mode, rf_slave.buff);
                                      
                              PCINT1 = OFF; // led off
                          }
                      }
                      
                              memset(rf_slave.buff, 0, sizeof(rf_slave.buff));
                      }
              
                      return rx_ok;
              }
              #endif /* RF_250KBPS */
1372          
1373          //------------------------------------------------------------------------
1374          //      Description     :       UART data to usb send
1375          //      Parameters      :       none
1376          //      Return          :       none
1377          //      Author          :       RAY
1378          //      Date            :       2014 - 03 - 11
1379          //------------------------------------------------------------------------
1380          void rf_slave_config(void)
1381          {
1382   1              UINT8 init_mac[4] = {MAC0, MAC1, MAC2, MAC3};
1383   1              
1384   1              rf_set_pipe(PIPE_INDEX_MAX);
1385   1              rf_set_ch();
1386   1              rf_set_mac(init_mac);
1387   1      
1388   1              rf_to_usb(INIT_MODE);
1389   1              rf_to_usb(INIT_MODE);
1390   1              rf_to_usb(INIT_MODE);
1391   1              
1392   1              rf_set_pipe((xn297l.mac[3] + 1) % PIPE_INDEX_MAX);
1393   1              rf_set_ch();
1394   1              rf_set_mac(xn297l.mac);
1395   1      }
1396          
1397          //------------------------------------------------------------------------
1398          //      Description     :       UART data to usb send
1399          //      Parameters      :       none
1400          //      Return          :       none
1401          //      Author          :       Sycreader
1402          //      Date            :       2014 - 03 - 11
1403          //------------------------------------------------------------------------
1404          void rf_slave_update(void)
1405          {
1406   1          #define _IAP_ADDR   0x0000 // Bootloader
1407   1          #define _FLAG_ADDR  (5*1024 + 512)
1408   1          
1409   1          UINT8 goto_flag[4] = {0xAA, 0xBB, 0xCC, 0xDD};
1410   1          
1411   1          Flash_PageErase(_FLAG_ADDR);
1412   1          Flash_Write(_FLAG_ADDR, goto_flag, 4);
1413   1          
C51 COMPILER V9.01   UART2USB                                                              11/08/2018 16:54:03 PAGE 24  

1414   1          // Disable All Interrupt. 
1415   1          _sfrb_bank0();
1416   1          IE0 = 0;
1417   1          IE1 = 0;
1418   1          IE2 = 0;
1419   1          IE3 = 0;
1420   1      
1421   1          // Goto Iap Start ADDR.
1422   1          ((void (code *)(void))_IAP_ADDR)();
1423   1      }
1424          
1425          #endif
1426          
1427          #endif /* _UART2USB */
1428          
*** WARNING C290 IN LINE 91 OF CODE\APP\SRC\UART2USB.C: missing return value
*** WARNING C291 IN LINE 1037 OF CODE\APP\SRC\UART2USB.C: not every exit path returns a value


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1774    ----
   CONSTANT SIZE    =      8    ----
   XDATA SIZE       =   1630      63
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  6 WARNING(S),  0 ERROR(S)
